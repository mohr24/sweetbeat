<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// variable initialization

x_start = x;
y_start = y;

x_vel = 0;
y_vel = 0;

begin_x = x;
begin_y = y;

facing = 1;

x_vel_ground = 0;

x_stick = 0;    // 8 point direction (center included)
y_stick = 0;
x_stick_square = 0; // 4 points not 8 (center included)
y_stick_square = 0;
x_stick_square_prev = 0;
y_stick_square_prev = 0;

grav_accel = 1;
move_accel = 1;
move_speed = 8;
air_speed = 15;
move_deccel = 2;
move_drag = .92;
top_drag_speed = 8;

prev_collisions_left = ds_list_create();
prev_collisions_right = ds_list_create();
prev_collisions_top = ds_list_create();
prev_collisions_bottom = ds_list_create();

next_collisions_left = ds_list_create();
next_collisions_right = ds_list_create();
next_collisions_top = ds_list_create();
next_collisions_bottom = ds_list_create();

death_wait = obj_manager.fpb;
death_count = -1;

// view manager must come after us
instance_create(x,y,obj_view_manager);

image_speed = 0;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// jump variables

jmp_vel = -20;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// swipe variables

swipe_total_frames = .5 * (30); // 1/2 beat
swipe_delay_frames = 3;
swipe_pre_delay_frames = 8;
swipe_post_animation_lag = 10;   // the sprite lives, but everything else is dead
swipe_target_distance = 5 * 64; // 5 blocks traveled in our 1/2 beat
swipe_non_physical_speed_demultiplier = 1/2;    // reduce our speed after the animation is over


swipe_animation_frames = swipe_total_frames;
var sumation = swipe_animation_frames * (swipe_animation_frames + 1) / 2;
swipe_acceleration_per_frame = swipe_target_distance / sumation;

//swipe_vel_per_frame = swipe_target_distance / swipe_animation_frames;

swipe_instance = noone;
swipe_offset = sprite_width / 2;

swipe_x = 0;
swipe_y = 0;
swipe_dir_confirmed = false;

swipe_vel = 0;

swipe_delay_cumulate = 0;
swipe_stick_record = ds_queue_create();
temp_queue = ds_queue_create();
swipe_total_counter = swipe_total_frames + swipe_post_animation_lag;   // an up counter for once
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// clean up?

ds_list_destroy(prev_collisions_left);
ds_list_destroy(prev_collisions_right);
ds_list_destroy(prev_collisions_top);
ds_list_destroy(prev_collisions_bottom);

ds_list_destroy(next_collisions_left);
ds_list_destroy(next_collisions_right);
ds_list_destroy(next_collisions_top);
ds_list_destroy(next_collisions_bottom);

ds_queue_destroy(swipe_stick_record);
ds_queue_destroy(temp_queue);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// calculate push distance
var push_x = x - begin_x;
var push_y = y - begin_y;

if (x_vel == 0 || sign(push_x) == -sign(x_vel) || abs(push_x) &gt; abs(x_vel))
    x_vel = push_x;
    
if (y_vel == 0 || sign(push_y) == -sign(y_vel) || abs(push_y) &gt; abs(y_vel))
    y_vel = push_y;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// player movement and collision triggering

var speed_cap = min(sprite_width, sprite_height);

//x_vel = floor(x_vel);   // odd errors with non integer velocities?
//y_vel = floor(y_vel);

/*
if (place_meeting(x, y, obj_solid_parent))
{
    var inst = instance_place(x,y,obj_solid_parent);
    var quad = Quadrant(inst,obj_player);
    switch (quad)
    {
    case quadrant.top:
        y = inst.bbox_top - sprite_yoffset;
        break;
    case quadrant.left:
        x = inst.bbox_left - sprite_xoffset;
        break;
    case quadrant.bottom:
        y = inst.bbox_bottom + sprite_yoffset;
        break;
    case quadrant.right:
        x = inst.bbox_right + sprite_xoffset;
        break;
    }
    if (place_meeting(x,y,obj_solid_parent))    // if still inside, reset
        obj_manager.mark_kill_player = true;
}
*/

x_vel_remain = x_vel;

while (x_vel_remain != 0)
{
    var x_vel_now = clamp(x_vel_remain, -speed_cap, speed_cap);
    if (place_meeting(x + x_vel_now, y, obj_solid_parent))
    {
        while (!place_meeting(x + sign(x_vel_now), y, obj_solid_parent))
            x += sign(x_vel_now);
        var lst;
        if (sign(x_vel_now) &gt; 0)
            lst = next_collisions_right;
        else
            lst = next_collisions_left;
        x_vel = 0;
        InstancePlaceList(lst, x + sign(x_vel_now), y, obj_solid_parent);
        for (var i = 0; i &lt; ds_list_size(lst); i += 1)
        {
            with (ds_list_find_value(lst,i))
                event_perform(ev_collision, obj_player); // register a collision event (wouldn't happen normally since we stop before it)
        }
        break;
    }
    x += x_vel_now;
    x_vel_remain -= x_vel_now;
}

x_vel_remain = 0;

y_vel_remain = y_vel;

while (y_vel_remain != 0)
{
    var y_vel_now = clamp(y_vel_remain, -speed_cap, speed_cap);
    if (place_meeting(x, y + y_vel_now, obj_solid_parent))
    {
        while (!place_meeting(x, y + sign(y_vel_now), obj_solid_parent))
            y += sign(y_vel_now);
        var lst;
        if (sign(y_vel_now) &gt; 0)
            lst = next_collisions_bottom;
        else
            lst = next_collisions_top;
        InstancePlaceList(lst, x, y + sign(y_vel_now), obj_solid_parent);
        y_vel = 0;
        for (var i = 0; i &lt; ds_list_size(lst); i += 1)
        {
            with (ds_list_find_value(lst, i))
            {
                event_perform(ev_collision, obj_player); // register a collision event (wouldn't happen normally since we stop before it)
                if (sign(y_vel_now) &gt; 0)
                    obj_player.x_vel_ground = x_vel;
            }
        }
        break;
    }
    y += y_vel_now;
    y_vel_remain -= y_vel_now;
}

y_vel_remain = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// swipe position update

if (swipe_instance != noone)
{
    var ox = swipe_x*swipe_offset;
    var oy = swipe_y*swipe_offset;
    if (swipe_x == 0 &amp;&amp; swipe_y == 0)
        ox = swipe_offset;
    swipe_instance.image_angle = point_direction(0,0,swipe_x,swipe_y);
    swipe_instance.x = x + ox;
    swipe_instance.y = y + oy;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// reset player position on death

if (obj_manager.kill_player &amp;&amp; death_count &lt;= 0)
{
    audio_play_sound(snd_death, 10, false);
    instance_create(x,y,obj_player_respawn);    
    if (obj_manager.checkpoint_id == 0)
    {
        x = x_start;
        y = y_start;
    }
    else
    {
        x = obj_manager.checkpoint_id.x;
        y = obj_manager.checkpoint_id.bbox_bottom - sprite_height / 2;
     //   obj_manager.sequence = noone;
      //  obj_manager.sequence[0] = Pair(0,command.none);
    }
    if (swipe_instance != noone)
        with (swipe_instance)
            instance_destroy();
    swipe_instance = noone;
    death_count = death_wait;
    
    with (obj_player_respawn){
        ani_time = other.death_wait;
        target_y = other.y;
        target_x = other.x;
    }
  //  var frames_left = (obj_manager.fpb * obj_manager.bpm - obj_manager.counter);
   // if(frames_left &lt; obj_manager.fpb){
   //     death_count = frames_left + obj_manager.fpb * obj_manager.bpm;
   // }else{
    //    death_count = frames_left;
  //  }
    
    x_vel = 0;
    y_vel = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// update frame collision lists

ds_list_copy(prev_collisions_left, next_collisions_left);
ds_list_copy(prev_collisions_right, next_collisions_right);
ds_list_copy(prev_collisions_top, next_collisions_top);
ds_list_copy(prev_collisions_bottom, next_collisions_bottom);

ds_list_clear(next_collisions_left);
ds_list_clear(next_collisions_right);
ds_list_clear(next_collisions_top);
ds_list_clear(next_collisions_bottom);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// record location for pushing

begin_x = x;
begin_y = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// player control and gravity

var horizontal_axis;
var vertical_axis;

var h_axis_2;
var v_axis_2;

var deadzone = .5;

// set previouses
x_stick_square_prev = x_stick_square;
y_stick_square_prev = y_stick_square;

// controller check
if (gamepad_is_connected(0))
{
    horizontal_axis = gamepad_axis_value(0, gp_axislh);
    vertical_axis = gamepad_axis_value(0, gp_axislv);
    
    h_axis_2 = gamepad_axis_value(0, gp_axisrh);
    v_axis_2 = gamepad_axis_value(0, gp_axisrv);
    
    
    
    // deadzone checks
    if (abs(horizontal_axis) &lt; deadzone)
        horizontal_axis = 0;
    if (abs(vertical_axis) &lt; deadzone)
        vertical_axis = 0;
    if (abs(h_axis_2) &lt; deadzone)
        h_axis_2 = 0;
    if (abs(v_axis_2) &lt; deadzone)
        v_axis_2 = 0;
}
else // keyboard check
{
    h_axis_2 = keyboard_check(ord('D')) - keyboard_check(ord('A'));
    v_axis_2 = keyboard_check(ord('S')) - keyboard_check(ord('W'));
    horizontal_axis = keyboard_check(vk_right) - keyboard_check(vk_left);
    vertical_axis = keyboard_check(vk_down) - keyboard_check(vk_up);

}
if(h_axis_2 == 0 &amp;&amp; v_axis_2 == 0){
    h_axis_2 = horizontal_axis;
    v_axis_2 = vertical_axis;
}
x_stick = clamp(h_axis_2 / deadzone, -1, 1); // -1, 0, or 1
y_stick = clamp(v_axis_2 / deadzone, -1, 1);   // division by deadzone to make easy math
if (y_stick == 0)
{
    y_stick_square = 0;
    x_stick_square = x_stick;
}
else
{
    x_stick_square = 0;
    y_stick_square = y_stick;
}

if(x_stick != 0){
    facing = x_stick;
}

// variable updates
var x_vel_target = horizontal_axis * move_speed;

var x_accel = move_accel;
if (sign(horizontal_axis) != sign(x_vel))
    x_accel = move_deccel;
x_vel_target += x_vel_ground;

if(ds_list_size(prev_collisions_bottom) &gt; 0){
    if (x_vel &gt; x_vel_target + x_accel)
        x_vel -= x_accel;
    else if (x_vel &lt; x_vel_target - x_accel)
        x_vel += x_accel;
    else
        x_vel = x_vel_target;
}else{
    if(horizontal_axis != 0)
    {
        if (sign(x_vel - x_vel_target) != sign(horizontal_axis))
        {
            if (x_vel &gt; x_vel_target + x_accel)
                x_vel -= x_accel;
            else if (x_vel &lt; x_vel_target - x_accel)
                x_vel += x_accel;
            else
                x_vel = x_vel_target;
        }
    }
    else if (y_vel &gt; 0)// &amp;&amp; y_vel &lt; top_drag_speed)
    {
        x_vel *= move_drag;   
    }
}

y_vel += grav_accel;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// swipe
if (ds_queue_size(swipe_stick_record) == swipe_pre_delay_frames)
    ds_queue_dequeue(swipe_stick_record);
ds_queue_enqueue(swipe_stick_record, Pair(x_stick_square,y_stick_square));

if (CheckCommand(command.swipe))
{
    swipe_total_counter = 0;
    swipe_vel = 0;
    swipe_dir_confirmed = false;
    if (swipe_instance != noone)
        with (swipe_instance)
            instance_destroy();
    swipe_instance = noone;
    swipe_delay_cumulative = 0;
    if (!ds_queue_empty(swipe_stick_record))
    {
        ds_queue_copy(temp_queue, swipe_stick_record);
        var prev = ds_queue_dequeue(temp_queue);
        swipe_x = prev[0];
        swipe_y = prev[1];
        while (!ds_queue_empty(temp_queue))
        {
            var next = ds_queue_dequeue(temp_queue);
            swipe_x = next[0];
            swipe_y = next[1];
            // if it changes, and the change is to a (non-zero) direction, we confirm
            if ((next[0] != prev[0] || next[1] != prev[1]) &amp;&amp; (next[0] != 0 || next[1] != 0))
            {
                swipe_dir_confirmed = true;
                break;
            }
            prev[0] = next[0];
            prev[1] = next[1];
        }
    }
    else
        show_debug_message("ERROR SWIPE QUEUE EMPTY");
    //show_debug_message("swipe start");
}

if (swipe_total_counter &lt; swipe_total_frames + swipe_post_animation_lag)
{
    //if (x_stick_square != 0 || y_stick_square != 0)
    //    show_debug_message("stick");
    if (swipe_total_counter &lt; swipe_total_frames)
    {
        swipe_vel += swipe_acceleration_per_frame;
        swipe_delay_cumulative += swipe_vel;
        if (swipe_total_counter &lt;= swipe_delay_frames &amp;&amp; !swipe_dir_confirmed)
        {
            x_vel = 0;
            y_vel = 0;
            swipe_x = x_stick_square;
            swipe_y = y_stick_square;
            // if we run out of frames, or we push the stick to a (non-zero) direction
            if (swipe_total_counter == swipe_delay_frames ||
                ((x_stick_square != x_stick_square_prev || y_stick_square != y_stick_square_prev) &amp;&amp;
                (x_stick_square != 0 || y_stick_square != 0)))            
            {
                x_vel = swipe_x*swipe_delay_cumulative;
                y_vel = swipe_y*swipe_delay_cumulative;
                swipe_dir_confirmed = true;
                //show_debug_message("swipe frame");
            }
        }
        else
        {
            if (swipe_instance == noone)
                swipe_instance = instance_create(x, y, obj_swipe);  // moved end of frame
            x_vel = swipe_x*swipe_vel;
            y_vel = swipe_y*swipe_vel;
        }
        swipe_total_counter += 1;
        
        //if (swipe_total_counter == swipe_total_frames - 1)
        //    show_debug_message("swipe end");
    }
    else
    {
        if (swipe_total_counter == swipe_total_frames)
        {
            x_vel *= swipe_non_physical_speed_demultiplier;
            y_vel *= swipe_non_physical_speed_demultiplier;
        }
        swipe_total_counter += 1;
        if (swipe_total_counter == swipe_total_frames + swipe_post_animation_lag)
        {
            if (swipe_instance != noone)
                with (swipe_instance)
                    instance_destroy();
            swipe_instance = noone;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// jump action
if (CheckCommand(command.jump))
{
    y_vel = jmp_vel;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// check respawn timer

if (death_count &gt; 0)
{
    death_count -= 1;
    x_vel = 0;
    y_vel = 0;
}

if (death_count == 0)
{
    death_count = 1;
   // obj_manager.sequence = obj_manager.checkpoint_id.sequence;
    if (obj_manager.tick_beat || obj_manager.beat_id == 0){
        death_count = -1;
        with (obj_player_respawn) { instance_destroy(); } 
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debug! set position to mouse coordinates
x = mouse_x;
y = mouse_y;

x_vel = 0;
y_vel = 0;
begin_x = x;
begin_y = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>203</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_kill_object</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// signal our death

obj_manager.mark_kill_player = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// manual draw object
if (death_count == -1)  // don't show until respawned completely
{
   // draw_sprite(sprite_index,image_index,x,y);
    draw_sprite_ext(sprite_index,image_index,x,y,facing,1,0,-1,1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="57">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debug! advance checkpoint

var cpid = -1;
var cpcount = 0;

var bid = 0;
with (obj_beat)
{
    if (id == obj_manager.beat_id)
        cpid = bid;
    bid += 1;
    cpcount += 1;
}
cpid += 1;

if (cpid &lt; 0)
    cpid += cpcount;
else if (cpid &gt;= cpcount)
    cpid -= cpcount;
bid = 0;
var nx = x_start;
var ny = y_start;

with (obj_beat)
{
    if (bid == cpid)
    {
        nx = x;
        ny = y;
        event_perform(ev_collision,obj_player);
    }
    bid += 1;
}

x = nx;
y = ny - sprite_height/2;
x_vel = 0;
y_vel = 0;
begin_x = x;
begin_y = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="48">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debug! retreat checkpoint

var cpid = 0;
var cpcount = 0;

var bid = 0;
with (obj_beat)
{
    if (id == obj_manager.beat_id)
        cpid = bid;
    bid += 1;
    cpcount += 1;
}
cpid -= 1;
if (cpid &lt; 0)
    cpid += cpcount;
else if (cpid &gt;= cpcount)
    cpid -= cpcount;
bid = 0;
var nx = x_start;
var ny = y_start;

with (obj_beat)
{
    if (bid == cpid)
    {
        nx = x;
        ny = y;
        event_perform(ev_collision,obj_player);
    }
    bid += 1;
}

x = nx;
y = ny - sprite_height/2;
x_vel = 0;
y_vel = 0;
begin_x = x;
begin_y = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>32,32</point>
    <point>32,32</point>
  </PhysicsShapePoints>
</object>
