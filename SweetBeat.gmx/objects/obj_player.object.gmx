<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// variable initialization

show_debug_message("player Create");

x_start = x;
y_start = y;

x_vel = 0;
y_vel = 0;

x_vel_ground = 0;

x_stick = 0;    // 8 point direction (center included)
y_stick = 0;
x_stick_square = 0; // 4 points not 8 (center included)
y_stick_square = 0;

grav_accel = 1;
move_accel = 1;
move_speed = 8;
air_speed = 15;
wall_slide_speed = 6.5;
wall_deccel = 3;

prev_collisions_left = ds_list_create();
prev_collisions_right = ds_list_create();
prev_collisions_top = ds_list_create();
prev_collisions_bottom = ds_list_create();

next_collisions_left = ds_list_create();
next_collisions_right = ds_list_create();
next_collisions_top = ds_list_create();
next_collisions_bottom = ds_list_create();

death_wait = obj_manager.fpb;
death_count = -1;

// view manager must come after us
instance_create(x,y,obj_view_manager);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// jump variables

jmp_vel = -20;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// wall kick variables

wall_kick_h_vel = 16;
wall_kick_v_vel = 16;

wall_kick_animation = 5;
wall_kick_scale = 1.1;

wall_kick_count = 0;

wall_kick_stretch = 1;

wall_kick_tolerance = 6;

wall_kick_left_wall = 0;
wall_kick_right_wall = 0;

wall_kick_cols = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///grapple variables

my_swing = noone;
swing_x_stick = 0;
swing_y_stick = 0;
grapple_length = 0;
max_length = 400;
in_swing = 0;
swing_vel = 10;
mark_for_finish = false;
rotation_boost = 2;
y_adjust = 2;

swing_duration = 45;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///dive and speed up
max_move = 100; // for dive
continue_move = false;


speed_up_step = .25 * room_speed;
step_left = 0;
speed_up_s = 10;
continue_speed = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// swipe variables

swipe_life = .5*30;
swipe_length = .25*30;
swipe_count = 0;
swipe_life_count = 0;

swipe_vel = 28;

swipe_instance = noone;
swipe_offset = sprite_width / 2;

swipe_off_x = 0;
swipe_off_y = 0;

swipe_delay = -1;
swipe_tolerance = 5;
swipe_stick_x = 0;
swipe_stick_y = 0;
swipe_stick_timer = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// clean up?

ds_list_destroy(prev_collisions_left);
ds_list_destroy(prev_collisions_right);
ds_list_destroy(prev_collisions_top);
ds_list_destroy(prev_collisions_bottom);

ds_list_destroy(next_collisions_left);
ds_list_destroy(next_collisions_right);
ds_list_destroy(next_collisions_top);
ds_list_destroy(next_collisions_bottom);

ds_list_destroy(wall_kick_cols);

show_debug_message("player destroy");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// update frame collision lists

ds_list_copy(prev_collisions_left, next_collisions_left);
ds_list_copy(prev_collisions_right, next_collisions_right);
ds_list_copy(prev_collisions_top, next_collisions_top);
ds_list_copy(prev_collisions_bottom, next_collisions_bottom);

ds_list_clear(next_collisions_left);
ds_list_clear(next_collisions_right);
ds_list_clear(next_collisions_top);
ds_list_clear(next_collisions_bottom);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// player control and gravity

var horizontal_axis;
var vertical_axis;

var h_axis_2;
var v_axis_2;

var deadzone = .5;

// controller check
if (gamepad_is_connected(0))
{
    horizontal_axis = gamepad_axis_value(0, gp_axislh);
    vertical_axis = gamepad_axis_value(0, gp_axislv);
    
    h_axis_2 = gamepad_axis_value(0, gp_axisrh);
    v_axis_2 = gamepad_axis_value(0, gp_axisrv);
    
    
    
    // deadzone checks
    if (abs(horizontal_axis) &lt; deadzone)
        horizontal_axis = 0;
    if (abs(vertical_axis) &lt; deadzone)
        vertical_axis = 0;
    if (abs(h_axis_2) &lt; deadzone)
        h_axis_2 = 0;
    if (abs(v_axis_2) &lt; deadzone)
        v_axis_2 = 0;
}
else // keyboard check
{
    h_axis_2 = keyboard_check(ord('D')) - keyboard_check(ord('A'));
    v_axis_2 = keyboard_check(ord('S')) - keyboard_check(ord('W'));
    horizontal_axis = keyboard_check(vk_right) - keyboard_check(vk_left);
    vertical_axis = keyboard_check(vk_down) - keyboard_check(vk_up);

}
if(h_axis_2 == 0 &amp;&amp; v_axis_2 == 0){
    h_axis_2 = horizontal_axis;
    v_axis_2 = vertical_axis;
}

// variable updates
var x_vel_target = horizontal_axis * move_speed;
x_vel_target += x_vel_ground;

if(ds_list_size(prev_collisions_bottom) &gt; 0){
    if (x_vel &gt; x_vel_target + move_accel)
        x_vel -= move_accel;
    else if (x_vel &lt; x_vel_target - move_accel)
        x_vel += move_accel;
    else
        x_vel = x_vel_target;
}else{
    if(horizontal_axis &gt; 0){
        if(x_vel &lt; x_vel_target - move_accel)
            x_vel += move_accel;
        else if(x_vel == x_vel_target - move_accel)
            x_vel = x_vel_target;
    }else if(horizontal_axis &lt; 0){
        if(x_vel &gt; x_vel_target + move_accel)
            x_vel -= move_accel;
        else if(x_vel == x_vel_target + move_accel)
            x_vel = x_vel_target;
    }
}

y_vel += grav_accel;
x_stick = clamp(h_axis_2 / deadzone, -1, 1); // -1, 0, or 1
y_stick = clamp(v_axis_2 / deadzone, -1, 1);   // division by deadzone to make easy math
if (y_stick == 0)
{
    y_stick_square = 0;
    x_stick_square = x_stick;
}
else
{
    x_stick_square = 0;
    y_stick_square = y_stick;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// reset player position on death

if (obj_manager.kill_player)
{
    if (obj_manager.checkpoint_id == 0)
    {
        x = x_start;
        y = y_start;
    }
    else
    {
        x = obj_manager.checkpoint_id.x;
        y = obj_manager.checkpoint_id.y;
    }
    death_count = death_wait;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// jump action
if (CheckCommand(command.jump))
{
    y_vel = jmp_vel;
    audio_play_sound(snd_jump,10,false);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// wall slide

var wall_collisions = ds_list_size(prev_collisions_left) + ds_list_size(prev_collisions_right);

if (wall_collisions != 0 &amp;&amp; y_vel &gt; wall_slide_speed)
{
    y_vel -= wall_deccel;
    if (y_vel &lt; wall_slide_speed)
        y_vel = wall_slide_speed;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// swipe

if (x_stick_square != 0 || y_stick_square != 0)
{
    swipe_stick_x = x_stick_square;
    swipe_stick_y = y_stick_square;
    swipe_stick_timer = 2*swipe_tolerance;  // forward and backwards = x2
}
else if (swipe_stick_timer &gt; 0)
{
    swipe_stick_timer -= 1;
}
else
{
    swipe_stick_x = 0;
    swipe_stick_y = 0;
}

if (CheckCommand(command.swipe))
{
    audio_play_sound(snd_swipe, 10, false);
    swipe_delay = swipe_tolerance;
}

if (swipe_delay == 0)
{
    swipe_delay = -1;
    swipe_count = swipe_length;
    swipe_life_count = swipe_life;
    if (swipe_instance != noone)
    {
        with (swipe_instance)
            instance_destroy();
        swipe_instance = noone;
    }
    swipe_off_x = swipe_stick_x * swipe_offset;
    swipe_off_y = swipe_stick_y * swipe_offset;
    if (swipe_stick_x != 0 || swipe_stick_y != 0)
    {
        swipe_instance = instance_create(x + swipe_off_x, y + swipe_off_y, obj_swipe);
        swipe_instance.image_angle = point_direction(0,0,swipe_stick_x,swipe_stick_y);
    }
    else
    {
        swipe_instance = instance_create(x + swipe_offset, y, obj_swipe);
    }
}
    
if (swipe_count &gt; 0)
{
    var inter = (swipe_length - swipe_count) / swipe_length;
    x_vel = inter * sign(swipe_off_x)*swipe_vel;
    y_vel = inter * sign(swipe_off_y)*swipe_vel;
    swipe_count -= 1;
}

if (swipe_delay &gt;= 0)
{
    swipe_delay -= 1;
    //x_vel = 0;
    //y_vel = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// check respawn timer

if (death_count &gt; 0)
{
    death_count -= 1;
    x_vel = 0;
    y_vel = 0;
}

if (death_count == 0)
{
    death_count = 1;
    if (obj_manager.tick_beat || obj_manager.beat_id == 0)
        death_count = -1;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// player movement and collision triggering

var speed_cap = min(sprite_width, sprite_height);

x_vel = floor(x_vel);   // odd errors with non integer velocities?
y_vel = floor(y_vel);

/*
if (place_meeting(x, y, obj_solid_parent))
{
    var inst = instance_place(x,y,obj_solid_parent);
    var quad = Quadrant(inst,obj_player);
    switch (quad)
    {
    case quadrant.top:
        y = inst.bbox_top - sprite_yoffset;
        break;
    case quadrant.left:
        x = inst.bbox_left - sprite_xoffset;
        break;
    case quadrant.bottom:
        y = inst.bbox_bottom + sprite_yoffset;
        break;
    case quadrant.right:
        x = inst.bbox_right + sprite_xoffset;
        break;
    }
    if (place_meeting(x,y,obj_solid_parent))    // if still inside, reset
        obj_manager.mark_kill_player = true;
}
*/

x_vel_remain = x_vel;

while (x_vel_remain != 0)
{
    var x_vel_now = clamp(x_vel_remain, -speed_cap, speed_cap);
    if (place_meeting(x + x_vel_now, y, obj_solid_parent))
    {
        while (!place_meeting(x + sign(x_vel_now), y, obj_solid_parent))
            x += sign(x_vel_now);
        var lst;
        if (sign(x_vel_now) &gt; 0)
            lst = next_collisions_right;
        else
            lst = next_collisions_left;
        x_vel = 0;
        InstancePlaceList(lst, x + sign(x_vel_now), y, obj_solid_parent);
        for (var i = 0; i &lt; ds_list_size(lst); i += 1)
        {
            with (ds_list_find_value(lst,i))
                event_perform(ev_collision, obj_player); // register a collision event (wouldn't happen normally since we stop before it)
        }
        //x_vel += sign(x_vel_now);    // slight atraction to wall so we slide better
        break;
    }
    x += x_vel_now;
    x_vel_remain -= x_vel_now;
}

x_vel_remain = 0;

y_vel_remain = y_vel;

while (y_vel_remain != 0)
{
    var y_vel_now = clamp(y_vel_remain, -speed_cap, speed_cap);
    if (place_meeting(x, y + y_vel_now, obj_solid_parent))
    {
        while (!place_meeting(x, y + sign(y_vel_now), obj_solid_parent))
            y += sign(y_vel_now);
        var lst;
        if (sign(y_vel_now) &gt; 0)
            lst = next_collisions_bottom;
        else
            lst = next_collisions_top;
        InstancePlaceList(lst, x, y + sign(y_vel_now), obj_solid_parent);
        y_vel = 0;
        for (var i = 0; i &lt; ds_list_size(lst); i += 1)
        {
            with (ds_list_find_value(lst, i))
            {
                event_perform(ev_collision, obj_player); // register a collision event (wouldn't happen normally since we stop before it)
                if (sign(y_vel_now) &gt; 0)
                    obj_player.x_vel_ground = x_vel;
            }
        }
        break;
    }
    y += y_vel_now;
    y_vel_remain -= y_vel_now;
}

y_vel_remain = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// swipe position update

if (swipe_life_count &gt; 0)
{
    if (swipe_instance != noone)
    {
        if (swipe_off_x == 0 &amp;&amp; swipe_off_y == 0)
        {
            swipe_instance.x = x + swipe_offset;
            swipe_instance.y = y;
        }
        else
        {
            swipe_instance.x = x + swipe_off_x;
            swipe_instance.y = y + swipe_off_y;
        }
    }
    swipe_life_count -= 1;
}
else if (swipe_instance != noone)
{
    with (swipe_instance)
        instance_destroy();
    swipe_instance = noone;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///new_grapple

if(CheckCommand(command.swing)){
    if (my_swing != noone)
        with (my_swing)
            instance_destroy();

    anchor = instance_nearest(x,y,obj_anchor);
    grapple_length = point_distance(x,y,anchor.x,anchor.y);
    if(grapple_length &gt; max_length){
        //do something
        return 0;
    }
    my_swing = instance_create(x,y,obj_swing);
    with(my_swing){
        start_x = other.x;
        start_y = other.y;
        end_x = other.anchor.x;
        end_y = other.anchor.y;
    }
    player_angle = point_direction(0,0,x_vel,y_vel);
    grapple_angle = point_direction(x,y,anchor.x,anchor.y);
    
    vel_magnitude = point_distance(0,0,x_vel,y_vel)+.01;
    
     show_debug_message("player_angle "+string(player_angle));
    show_debug_message("grapple_angle + 90 "+string(grapple_angle +90));
    //projection of player velocity onto swing direction
    swing_velocity = vel_magnitude  * dcos(angle_difference(player_angle, grapple_angle-90));
    /*if(swing_magnitude &gt; 0){
        swing_dir = "clockwise";
    }else if(swing_magnitude &lt; 0){
        swing_dir = "counter-clockwise";
    } */
    rotation_speed = 360*(swing_velocity) / (grapple_length*2 * pi); 
      show_debug_message("vel_magnitude "+string(vel_magnitude));
    show_debug_message("swing_velocity "+string(swing_velocity));
    show_debug_message("grapple_length "+string(grapple_length));
    show_debug_message("rotation_speed "+string(rotation_speed));
    show_debug_message("grapple_angle "+string(grapple_angle));
    in_swing = swing_duration;

}
if(in_swing &gt; 0){
    in_swing --;
    grapple_angle += rotation_speed;
    //show_debug_message("grapple_angle in swing"+string(grapple_angle));
    with(my_swing){
        start_x = other.x;
        start_y = other.y;
        end_x = other.anchor.x;
        end_y = other.anchor.y;
    }
    x_vel = 0;
    y_vel = 0;
    x_vel = anchor.x-grapple_length*dcos(grapple_angle) - x;
    y_vel = anchor.y-grapple_length*-dsin(grapple_angle) - y;

    
} else if(in_swing == 0){
    with(my_swing){
        instance_destroy();
    }
    my_swing = noone;
}
else if (my_swing != noone)
{
    with(my_swing){
        instance_destroy();
    }
    my_swing = noone;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// wall kick action

if (wall_kick_left_wall &gt; 0)
    wall_kick_left_wall -= 1;

if (wall_kick_right_wall &gt; 0)
    wall_kick_right_wall -= 1;

if (ds_list_size(prev_collisions_left))
{
    wall_kick_left_wall = wall_kick_tolerance;
    ds_list_copy(wall_kick_cols, prev_collisions_left);
}
if (ds_list_size(prev_collisions_right))
{
    wall_kick_right_wall = wall_kick_tolerance;
    ds_list_copy(wall_kick_cols, prev_collisions_right);
}
    
if (CheckCommand(command.wall_kick))
{
    wall_kick_count = wall_kick_animation;
    if (ds_list_size(prev_collisions_bottom) || wall_kick_left_wall &gt; 0 || wall_kick_right_wall &gt; 0)
    {
        y_vel = -wall_kick_v_vel;
        if (ds_list_size(prev_collisions_bottom) &gt; 0)
        {
            for (var i = 0; i &lt; ds_list_size(prev_collisions_bottom); i += 1)
                with (ds_list_find_value(prev_collisions_bottom, i))
                    trigger = true;
        }
        else
        {
            if (wall_kick_left_wall &gt; wall_kick_right_wall)
                x_vel = wall_kick_h_vel;
            else
                x_vel = -wall_kick_h_vel;
            for (var i = 0; i &lt; ds_list_size(wall_kick_cols); i += 1)
            {
                with (ds_list_find_value(wall_kick_cols, i))
                {
                    event_perform(ev_collision, obj_player);    // we kick the wall even if we left it already
                    trigger = true;
                }
            }
        }
    }
    audio_play_sound(snd_wall_kick,10,false);
}

if (wall_kick_count &gt; 0)
{
    var inter = wall_kick_count / wall_kick_animation;
    wall_kick_stretch = wall_kick_scale * inter + 1*(1 - inter);
    wall_kick_count -= 1;
}
else
    wall_kick_stretch = 1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///grapple action

/*if(CheckCommand(command.swing)){
    
    if (my_swing != noone)
        with (my_swing)
            instance_destroy();
    if(place_meeting(x+1,y,obj_solid_parent)||
     place_meeting(x-1,y,obj_solid_parent)||
     place_meeting(x,y+1,obj_solid_parent)||
     place_meeting(x,y-1,obj_solid_parent)||
     x_stick_square == 0 &amp;&amp; y_stick_square == 0){
        return 0;
    }
    
    my_swing = instance_create(x,y,obj_swing);
    swing_x_stick = x_stick_square;
    swing_y_stick = y_stick_square;
    vel_magnitude = point_distance(0,0,x_vel,y_vel)+.01;
    
    player_angle = point_direction(0,0,x_vel,y_vel);
    goal_angle = point_direction(0,0,swing_x_stick,swing_y_stick);
    angle_diff = angle_difference(goal_angle,player_angle);
    show_debug_message("angle diff"+string(angle_diff));
    if(angle_diff&gt;0){
        swing_dir = "clockwise";
        swing_point_x = x+y_vel/vel_magnitude *grapple_length;
        swing_point_y = y-x_vel/vel_magnitude *grapple_length;
    }else{
        swing_dir = "counter-clockwise";
        swing_point_x = x-y_vel/vel_magnitude *grapple_length;
        swing_point_y = y+x_vel/vel_magnitude *grapple_length;
    }

    
    with(my_swing){
        start_x = x;
        start_y = y;
        end_x = other.swing_point_x;
        end_y = other.swing_point_y;
    }
    grapple_angle = point_direction(swing_point_x,swing_point_y,x,y);
    init_magnitude = vel_magnitude;
    in_swing = true;
    mark_for_finish = false;
    show_debug_message("xdiff"+string(swing_point_x+grapple_length*dcos(grapple_angle) - x));
    show_debug_message("ydiff"+string(swing_point_y+grapple_length*-dsin(grapple_angle) - y));
}

if(in_swing){
    
   // show_debug_message("goal"+string(goal_angle));
   // show_debug_message("grapple"+string(grapple_angle));
   // show_debug_message("diff"+string(angle_difference(goal_angle,grapple_angle)));
    
    if(mark_for_finish || obj_manager.mark_kill_player){
        in_swing=false;
        if (my_swing != noone)
        {
            with(my_swing){
                instance_destroy();
            }
            my_swing = noone;
        }
        x_vel = init_magnitude*dcos(goal_angle);
        y_vel = init_magnitude*-dsin(goal_angle)-y_adjust;
        return 0;
    }
    if(place_meeting(x+1,y,obj_solid_parent)||
     place_meeting(x-1,y,obj_solid_parent)||
     place_meeting(x,y+1,obj_solid_parent)||
     place_meeting(x,y-1,obj_solid_parent)){
        mark_for_finish = true;
        return 0;
    }
    if(swing_dir == "clockwise"){
        grapple_angle+=swing_vel;
        diff = angle_difference(goal_angle,grapple_angle)-90;

    }else if(swing_dir == "counter-clockwise"){
        grapple_angle-=swing_vel;
        diff = angle_difference(grapple_angle,goal_angle)-90;
    }
    
    if(diff&gt;=-swing_vel &amp;&amp; diff&lt;=swing_vel){
        grapple_angle += diff;
        mark_for_finish = true;
        
    }
    
    
    with(my_swing){
        start_x = other.x;
        start_y = other.y;
        end_x = other.swing_point_x;
        end_y = other.swing_point_y;
    }
    x_vel = 0;
    y_vel = 0;
    x_vel = swing_point_x+grapple_length*dcos(grapple_angle) - x;
    y_vel = swing_point_y+grapple_length*-dsin(grapple_angle) - y;
    
    

}else if (my_swing != noone)
{
    with(my_swing){
        instance_destroy();
    }
    my_swing = noone;
}
/*
if(in_shooting_grapple){
    
   // grapple_length += grapple_vel;
    with(my_swing){
        start_x = other.x;
        start_y = other.y;
        end_x = other.x+other.grapple_length*other.swing_x_stick;
        end_y = other.y+other.grapple_length*other.swing_y_stick;
    }
    if(outside_view(0,end_x,end_y)){
        with(my_swing) instance_destroy();
        in_shooting_grapple = false;
    }
    if(position_meeting(end_x,end_y,obj_solid_parent)){
        in_swing = swing_duration;
    }
}*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///dive

if (CheckCommand(command.dive) or continue_move){
    continue_move = true;
    var i = 0;
    while (not place_meeting(x, y + 1, obj_solid_parent)){
        y++; 
        i++;
        if (i&gt;=max_move) break;
    }
    if (place_meeting(x, y+1, obj_solid_parent)){
        continue_move = false;
        audio_play_sound(snd_dive,10,false);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///speed up


if (CheckCommand(command.speed_up)){
    step_left = speed_up_step;   
}

if (step_left &gt; 0){
    step_left--;
    x_vel += horizontal_axis * speed_up_s;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debug! set position to mouse coordinates
x = mouse_x;
y = mouse_y;

x_vel = 0;
y_vel = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// signal our death

obj_manager.mark_kill_player = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// manual draw object
if (death_count == -1)  // don't show until respawned completely
{
    if (wall_kick_count &gt; 0)
    {
        d3d_transform_set_identity();
        d3d_transform_add_scaling(wall_kick_stretch, wall_kick_stretch, 1);
        d3d_transform_add_translation(x, y, 0);
        draw_sprite(spr_player_wall_kick_border, 0, 0, 0);
        d3d_transform_set_identity();
    }
    draw_sprite(sprite_index,image_index,x,y);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>32,32</point>
    <point>32,32</point>
  </PhysicsShapePoints>
</object>
